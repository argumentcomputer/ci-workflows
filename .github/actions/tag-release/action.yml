# Workflow to create a new tag release when a release branch is merged
#
# Only supports running via the `pull_request` trigger in the caller workflow
name: Tag release

description: Bump crate versions and open release PR

inputs:
  tag-prefix:
    description: 'Tag prefix used to get most recent release'
    required: false
    default: ""
  changelog-path:
    description: 'Relative path to look for changelog'
    required: false
    default: "."
  changelog-config-file:
    description: 'Relative path to the config file for `mikepenz/release-changelog-builder-action`'
    required: false
    default: ""

runs:
  using: "composite"
  steps:
    - name: Get version
      id: get-version
      run: |
        RELEASE_BRANCH=${{ github.event.pull_request.base.ref }}

        if [[ -n "${{ inputs.tag-prefix }}" ]]; then
          TAG_PREFIX="${{ inputs.tag-prefix }}-"
        fi

        # On a major/minor release, insert a `.0` for the patch version)
        if [[ "${{ github.event.pull_request.head.ref }}" == "release-pr" ]]; then
          # Extract the version from the branch
          VERSION=$(echo "$RELEASE_BRANCH" | awk -F'-' '{print $(NF)}')

          D='0|[1-9][0-9]*'
          PW='[0-9]*[a-zA-Z-][0-9a-zA-Z-]*'
          MW='[0-9a-zA-Z-]+'
          SEMVER_REGEX="^v?($D)\.($D)(-(($D|$PW)(\.($D|$PW))*))?(\+($MW(\.$MW)*))?$"

          # Insert the `.0` patch version
          if [[ "$VERSION" =~ $SEMVER_REGEX ]]; then
            # Extract major, minor versions and anything after the patch (e.g., pre-release or build metadata)
            MAJOR="${BASH_REMATCH[1]}"
            MINOR="${BASH_REMATCH[2]}"
            EXTRA="${BASH_REMATCH[3]}"  # Pre-release or build metadata (if present)
            TAG_VERSION="${TAG_PREFIX}v$MAJOR.$MINOR.0$EXTRA"

            echo "Tag version: $TAG_VERSION"
          else
            echo "Failed to parse tag version from release branch name"
            exit 1
          fi
        else
          TAG_VERSION=$(echo "${{ github.event.pull_request.head.ref }}" | cut -d'/' -f 2)
        fi

        git tag -a $TAG_VERSION -m "$TAG_VERSION" origin/$RELEASE_BRANCH
        git push origin $TAG_VERSION --follow-tags
        echo "tag-version=$TAG_VERSION" | tee -a "$GITHUB_OUTPUT"
        echo "RELEASE_BRANCH=$RELEASE_BRANCH" | tee -a "$GITHUB_ENV"
      shell: bash

    - name: Get latest release reference
      id: get-latest-release
      run: |
        set +o pipefail
        LATEST_RELEASE=$(gh release list --repo ${{ github.repository }} --limit 100 | grep -Ei "${{ inputs.tag-prefix }}" | head -n 1 | awk '{ print $1 }')
        set -o pipefail

        if [ -z "$LATEST_RELEASE" ]; then
          LATEST_RELEASE=$(git rev-list --max-parents=0 HEAD)
          echo "The first commit on branch ${{ env.RELEASE_BRANCH }} is $LATEST_RELEASE"
        else
          echo "Found release: $LATEST_RELEASE"
        fi

        echo "latest_release=$LATEST_RELEASE" | tee -a "$GITHUB_OUTPUT"
      env:
        GH_TOKEN: ${{ github.token }}
      shell: bash

    # TODO: Add an automatic labeler for PRs based on title/commit prefix
    - name: Build Changelog
      id: github_release
      uses: mikepenz/release-changelog-builder-action@v5
      with:
        configuration: ${{ inputs.changelog-config-file }}
        path: "./${{ inputs.changelog-path }}"
        fromTag: ${{ steps.get-latest-release.outputs.latest_release }}
        toTag: ${{ steps.get-version.outputs.tag-version }}
      env:
        GITHUB_TOKEN: ${{ github.token }}

    - name: Create Release
      uses: ncipollo/release-action@v1
      with:
        body: ${{ steps.github_release.outputs.changelog }}
        tag: ${{ steps.get-version.outputs.tag-version }}
        commit: ${{ env.RELEASE_BRANCH }}
        allowUpdates: true
