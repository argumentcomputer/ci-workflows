# Patches a dependent crate with any upstream changes and checks that the former compiles
#
# Example:
# When run in `arecibo`, this workflow will check out `lurk-rs`, patch it with the local `arecibo` path,
# and check whether `lurk-rs` still builds.
#
# Only supports patching Git dependencies for now, crates.io patches are a TODO
# This workflow is not intended to be a required status check, but to surface breaking changes to 
# downstream repos for further review on e.g. `pull_request`.
name: Check downstream dependency compiles

on:
  workflow_call:
    secrets:
      PRIVATE_PULL_TOKEN:
        required: false
        description: ''
    inputs:
      runner:
        required: false
        default: 'ubuntu-latest'
        type: string
      # Downstream repo to check
      repository:
        required: false
        default: 'lurk-lab/lurk-rs'
        type: string
      # Used to checkout private repos
      token:
        required: false
        default: false
        type: boolean
      # List of prerequisite Ubuntu packages, separated by whitespace
      packages:
        required: false
        type: string
      # Patch with SSH instead of HTTPS
      patch-ssh:
        required: false
        default: false
        type: boolean

jobs:
  check-downstream-compiles:
    if: github.event_name == 'pull_request'
    runs-on: ${{ inputs.runner }}
    steps:
      - uses: actions/checkout@v4
        with:
          repository: lurk-lab/ci-workflows
      - uses: ./.github/actions/ci-env
      - uses: ./.github/actions/install-deps
        if: inputs.packages != ''
        with:
          packages: "${{ inputs.packages }}"
      - name: Set env
        run: |
          echo "DOWNSTREAM_REPO=$(echo ${{ inputs.repository }} | awk -F'/' '{ print $2 }')" | tee -a $GITHUB_ENV
          echo "UPSTREAM_REPO=$(echo ${{ github.repository }} | awk -F'/' '{ print $2 }')" | tee -a $GITHUB_ENV
      - uses: actions/checkout@v4
        with:
          path: ${{ github.workspace }}/${{ env.UPSTREAM_REPO }}
          submodules: recursive
      - uses: actions/checkout@v4
        if: inputs.token != true
        with:
          repository: ${{ inputs.repository }}
          path: ${{ github.workspace }}/${{ env.DOWNSTREAM_REPO }}
          submodules: recursive
      - uses: actions/checkout@v4
        if: inputs.token
        with:
          repository: ${{ inputs.repository }}
          path: ${{ github.workspace }}/${{ env.DOWNSTREAM_REPO }}
          submodules: recursive
          token: "${{ secrets.PRIVATE_PULL_TOKEN }}"
      - uses: dtolnay/rust-toolchain@stable
      - uses: Swatinem/rust-cache@v2
      - name: Patch Cargo.toml
        working-directory: ${{ github.workspace }}/${{ env.DOWNSTREAM_REPO }}
        run: |
          # Get each workspace package and relative path of the upstream crate, storing them in a map of former to latter
          if [[ "${{ inputs.patch-ssh }}" == "true" ]]; then
            URL=ssh://git@github.com/${{ github.repository }}
          else
            URL=https://github.com/${{ github.repository }}
          fi

          # Assumes at least one dependency in the current workspace is used by the downstream crate
          printf "\n[patch.'$URL']\n" | tee -a Cargo.toml

          # Get a list of all upstream dependencies used by the downstream crate workspace
          # This is done by checking for each instance of `git = <upstream_url>` in any of the downstream `Cargo.toml` files
          DEPENDENCIES=$(grep -rsh "git = \"$URL\"" --include="Cargo.toml" .)

          # Extract the dependency names and check for package renames, removing duplicates
          DEP_NAMES=$(echo "$DEPENDENCIES" | awk '/package =/{for (i=1; i<=NF; i++) if ($i == "package") {name=$(i+2); print substr(name, 2, length(name)-2);} found=1} !/package =/{print $1}' | sort -u)

          shopt -s nullglob
          # Collect the `package path` pairs for each subcrate in the directory, regardless of whether it's a workspace member
          SUBCRATES=$(grep -r -A1 --no-group-separator "\[package\]" --exclude-dir='.' --exclude-dir='target' ../${{ env.UPSTREAM_REPO }}/*/Cargo.toml | sed -n 'n;p' | awk -F'/' '{split($NF,a,"\""); print a[2], $(NF-1)}')
          shopt -u nullglob

          # Store the subcrates in associative array for retrieval when patching `Cargo.toml`
          declare -A subcrates
          while IFS= read -r line; do
              pair=($line)
              subcrates[${pair[0]}]=${pair[1]}
          done <<< "$SUBCRATES"

          # Write Git patches for each dependency used downstream
          # Note: The top-level workspace package if used will be included in `DEP_NAMES`, but not in `subcrates`
          # Therefore, below will append an empty string to the top-level path and patch it correctly
          for crate in $DEP_NAMES; do
            crate_path="${subcrates[$crate]}"
            echo "$crate = { path = \"../${{ env.UPSTREAM_REPO }}/$crate_path\" }" | tee -a Cargo.toml
          done
      - name: Check downstream types don't break spectacularly
        working-directory: ${{ github.workspace }}/${{ env.DOWNSTREAM_REPO }}
        run: cargo check --workspace --tests --benches --examples

